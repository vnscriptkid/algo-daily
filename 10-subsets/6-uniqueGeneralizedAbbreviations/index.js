// Unique Generalized Abbreviations

// Given a word, write a function to generate all of its unique generalized abbreviations.

// Generalized abbreviation of a word can be generated by
// replacing each substring of the word by the count of characters in the substring.
// Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”.
// After replacing these substrings in the actual word by the count of characters
// we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

// Input: "BAT"
// Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"

//                             ['']
//B:  [       'B'                              '1'          ]
//A:  [ 'BA'            'B1'            '1A',        '11'    ]
//T:  [ 'BAT' 'BA1' 'B1T'  'B11'    '1AT' '1A1'  '11T', '111']
//    [ 'BAT' 'BA1' 'B1T'  'B2'    '1AT' '1A1'  '2T', '3'    ]

class Node {
  constructor(cur, idx, count) {
    this.cur = cur
    this.idx = idx
    this.count = count
  }
}

function generateAbbreviations(word) {
  const queue = [new Node('', 0, 0)]

  const result = []

  while (queue.length) {
    let levelSize = queue.length

    while (levelSize > 0) {
      const {cur, idx, count} = queue.shift()
      // 2 choices:
      // choice 1: add char
      let newCur = count > 0 ? cur + count : cur
      newCur += word[idx]

      const node1 = new Node(newCur, idx + 1, 0)
      // choice 2: add 1
      const node2 = new Node(cur, idx + 1, count + 1)

      for (let node of [node1, node2]) {
        if (idx + 1 === word.length) {
          if (node.count > 0) node.cur += node.count
          result.push(node.cur)
        } else queue.push(node)
      }

      levelSize--
    }
  }

  return result
}

module.exports = {generateAbbreviations}
