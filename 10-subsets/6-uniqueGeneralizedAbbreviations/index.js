// Unique Generalized Abbreviations

// Given a word, write a function to generate all of its unique generalized abbreviations.

// Generalized abbreviation of a word can be generated by
// replacing each substring of the word by the count of characters in the substring.
// Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”.
// After replacing these substrings in the actual word by the count of characters
// we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

// Input: "BAT"
// Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"

//                             ['']
//B:  [         'B'                              '' (1)          ]
//A:  [ 'BA'            'B1'            '1A' (0),        '' (2)   ]
//T:  [ 'BAT' 'BA1' 'B1T'  'B11'    '1AT' '1A1'  '2T'(0), '3'(3)]
//    [ 'BAT' 'BA1' 'B1T'  'B2'    '1AT' '1A1'  '2T', '3'    ]

// Node: { curStr: '', idx: 0, count: 0}

class Node {
  constructor(curStr, idx, count) {
    this.curStr = curStr
    this.idx = idx
    this.count = count
  }
}

function generateAbbreviations(word) {
  const queue = []
  queue.push(new Node('', 0, 0))

  const result = []

  while (queue.length) {
    let {curStr, idx, count} = queue.shift()

    if (idx === word.length) {
      if (count > 0) curStr += count
      result.push(curStr)
    } else {
      // 2 choices:
      // choice 1: increment count
      queue.push(new Node(curStr, idx + 1, count + 1))
      // choice 2: add cur char: word[idx]
      let newCurStr = curStr
      if (count > 0) newCurStr += count
      newCurStr += word[idx]
      queue.push(new Node(newCurStr, idx + 1, 0))
    }
  }

  return result
}

module.exports = {generateAbbreviations}
